# C++ Curriculum Concepts List

1. 스마트 포인터 (Smart Pointers)
2. 람다 표현식 (Lambda Expressions)
3. std::jthread (C++20)
4. 쓰레드의 생명주기 (Lifecycle)
5. 인자 전달 (Argument Passing)
6. 하드웨어 동시성 (Hardware Concurrency)
7. 경쟁 조건 (Race Condition)
8. 상호 배제 (Mutual Exclusion)
9. Lock Guard (RAII)
10. Deadlock (교착 상태)
11. 락 순서 (Lock Ordering)
12. std::scoped_lock (C++17)
13. Polling vs Signaling
14. Producer-Consumer Pattern (생산자-소비자 패턴)
15. std::future & std::promise
16. std::async
17. std::shared_future
18. 쓰레드 생성 비용
19. 쓰레드 풀 (Thread Pool)
20. Thread-safe Queue
21. 원자성 (Atomicity)
22. Compare-And-Swap (CAS)
23. Spinlock (스핀락)
24. 재배치 (Reordering)
25. Memory Order
26. Acquire-Release Semantics
27. 동기(Sync) vs 비동기(Async) 로깅
28. Double Buffering (더블 버퍼링)
29. 소켓 (Socket)
30. TCP/IP
31. Winsock 초기화
32. Blocking I/O
33. select 함수
34. ioctlsocket
35. WSAEWOULDBLOCK
36. Select 모델의 한계
37. 브로드캐스팅 (Broadcasting)
38. RAII (Resource Acquisition Is Initialization)
39. 직렬화 (Serialization)
40. 동기 vs 비동기 DB
41. Connection Pool
42. Session ID
43. 스마트 포인터와 생명주기
44. Reactor vs Proactor
45. IOCP (Input/Output Completion Port)
46. Overlapped I/O
47. 세션 관리 (Session Management)
48. 패킷 구조 (Packet Structure)
49. Ring Buffer
50. Boost.Asio
51. Proactor Pattern in Asio
52. Completion Handler
53. shared_from_this
54. Write Queue
55. Strand
56. 프로파일링 (Profiling)
57. Sampling vs Instrumentation
58. 락 경합 (Lock Contention)
59. Layered Architecture
60. Dependency Rule
61. Session Abstraction
62. Listener Pattern
63. Service Locator
64. Packet Handling
65. Room Management
66. Dummy Client
67. Stress Testing
68. CCU & TPS
