import { promises as fs } from 'fs';
import path from 'path';

const viewerRoot = process.cwd();
const repoRoot = path.resolve(viewerRoot, '..');
const weeksOutputDir = path.join(viewerRoot, 'public', 'weeks');
const codeOutputDir = path.join(viewerRoot, 'public', 'code');
const manifestPath = path.join(viewerRoot, 'src', 'data', 'weeks.generated.ts');

const headingRegex = /^#\s+(.+)$/im;

const languageMap = {
  '.c': 'c',
  '.cc': 'cpp',
  '.cpp': 'cpp',
  '.cxx': 'cpp',
  '.h': 'cpp',
  '.hh': 'cpp',
  '.hpp': 'cpp',
  '.hxx': 'cpp',
  '.ixx': 'cpp',
  '.inl': 'cpp',
  '.md': 'markdown',
  '.txt': 'text',
  '.json': 'json',
  '.xml': 'xml',
  '.cmake': 'cmake',
  '.py': 'python',
  '.ps1': 'powershell'
};

const toPosix = (inputPath) => inputPath.replace(/\\/g, '/');

const removeMarkdown = (markdown) => {
  return markdown
    .replace(/```[\s\S]*?```/g, ' ')
    .replace(/`([^`]+)`/g, '$1')
    .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
    .replace(/[#>*_\-]+/g, ' ')
    .replace(/!\[[^\]]*\]\([^\)]*\)/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
};

const extractSummary = (content) => {
  const withoutFrontMatter = content.replace(/^---[\s\S]*?---/, '');
  const paragraphs = withoutFrontMatter.split(/\n{2,}/).map((block) => block.trim());
  const paragraph = paragraphs.find((block) => block && !block.startsWith('#'));
  if (!paragraph) {
    return '요약 정보가 없습니다.';
  }
  const cleaned = removeMarkdown(paragraph);
  return cleaned.length > 200 ? `${cleaned.slice(0, 197)}...` : cleaned;
};

const ensureDir = async (dirPath) => {
  await fs.mkdir(dirPath, { recursive: true });
};

const collectSources = async (weekName) => {
  const srcDir = path.join(repoRoot, weekName, 'src');
  const exists = await fs
    .access(srcDir)
    .then(() => true)
    .catch(() => false);

  if (!exists) {
    return [];
  }

  const targetRoot = path.join(codeOutputDir, weekName);
  await fs.rm(targetRoot, { recursive: true, force: true }).catch(() => {});
  await ensureDir(targetRoot);

  const files = [];

  const walk = async (dir) => {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const entryPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await walk(entryPath);
        continue;
      }
      const relative = path.relative(srcDir, entryPath);
      const targetFile = path.join(targetRoot, relative);
      await ensureDir(path.dirname(targetFile));
      await fs.copyFile(entryPath, targetFile);
      const ext = path.extname(entry.name).toLowerCase();
      files.push({
        name: toPosix(path.join('src', relative)),
        path: `/code/${weekName}/${toPosix(relative)}`,
        language: languageMap[ext] ?? 'text'
      });
    }
  };

  await walk(srcDir);
  return files.sort((a, b) => a.name.localeCompare(b.name));
};

const sync = async () => {
  const entries = await fs.readdir(repoRoot, { withFileTypes: true });
  const weeks = entries
    .filter((entry) => entry.isDirectory() && /^Week\d+$/.test(entry.name))
    .map((entry) => ({
      name: entry.name,
      index: Number(entry.name.replace('Week', ''))
    }))
    .sort((a, b) => a.index - b.index);

  if (!weeks.length) {
    console.warn('No Week directories found. Nothing to sync.');
    return;
  }

  await fs.rm(weeksOutputDir, { recursive: true, force: true });
  await fs.rm(codeOutputDir, { recursive: true, force: true });
  await ensureDir(weeksOutputDir);
  await ensureDir(codeOutputDir);

  const manifest = [];

  for (const week of weeks) {
    const sourcePath = path.join(repoRoot, week.name, 'README.md');
    const exists = await fs
      .access(sourcePath)
      .then(() => true)
      .catch(() => false);

    if (!exists) {
      console.warn(`Skipped ${week.name}: README.md not found.`);
      continue;
    }

    const raw = await fs.readFile(sourcePath, 'utf8');
    const headingMatch = raw.match(headingRegex);
    const title = headingMatch ? headingMatch[1].trim() : `C++ Study ${week.name}`;
    const summary = extractSummary(raw);

    const targetFile = `${week.name}.md`;
    await fs.writeFile(path.join(weeksOutputDir, targetFile), raw, 'utf8');

    const sources = await collectSources(week.name);

    manifest.push({
      id: week.name,
      title,
      path: `/weeks/${targetFile}`,
      summary,
      sources
    });
  }

  const typeDef = `export type WeekSourceFile = {\n  name: string;\n  path: string;\n  language: string;\n};\n\nexport type WeekMeta = {\n  id: string;\n  title: string;\n  path: string;\n  summary: string;\n  sources: WeekSourceFile[];\n};\n\n`;
  const manifestLiteral = `export const weeks: WeekMeta[] = ${JSON.stringify(manifest, null, 2)};\n`;
  const banner = `// Auto-generated by scripts/sync-weeks.mjs on ${new Date().toISOString()}\n// Do not edit manually.\n\n`;

  await ensureDir(path.dirname(manifestPath));
  await fs.writeFile(manifestPath, `${banner}${typeDef}${manifestLiteral}`, 'utf8');

  console.log(`Synced ${manifest.length} README files.`);
};

sync().catch((error) => {
  console.error('Failed to sync weekly README files.');
  console.error(error);
  process.exitCode = 1;
});
